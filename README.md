# Типы данных

## Переменные

Для хранения данных в программе в языке C++ используются переменные.  
Фактически переменная представляет именнованный участок памяти. Переменная имеет тип, имя и значение. Тип определяет, какие именно данные может хранить переменная.  
Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:  
```
тип_переменной имя_переменной;
```
**Именование переменных**

Имя переменной последовательность алфавитных-цифровых символов и знака подчеркивания _. При этом имя переменной должно начинаться с алфавитного символа или подчеркивания.  
Кроме того, в качестве имени переменной нельзя использовать ключевые слова языке C++, например, for или if. Но таких слов не так много, и по ходу освоения C++ вы соориентируетесь, какие слова являются ключевыми.  
**НЕ** рекомендуются следующие именования:  
- имена, которые начинаются с двух подчеркиваний
- имена, которые начинаются с подчеркивания, за которым идет заглавный алфавитный символ
- имена в глобальной области (вне функции main), которые начинаются с подчеркивания
  
Дело в том, что при подобных именах повышается вероятность, что подобные названия будут конфликтовать с именами (например, именами переменных),  
которые генерирует компилятор или которые определены в подключаемых стандартных модулях C++. Поэтому некоторые вообще не рекомендуют начинать имя с символа подчеркивания.  
Определение переменной
В общем случае переменная определяется в следующем виде:
```
int age;
```
Здесь определена переменная age, которая имеет тип int. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.  
Также стоит учитывать, что C++ - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:  
```
int age;
int Age;
```
Поэтому переменная Age не будет представлять то же самое, что и переменная age.  
Также нельзя объявить больше одной переменной с одним и тем же именем, например:  
```
int age;
int age;
```
Подобное определение вызовет ошибку на этапе компиляции.

**Инициализация**
После определения переменной можно присвоить некоторое значение. Присвоение переменной начального значения называется инициализацией.  
Рассмотрим виды инициализаций.  
```
#include <iostream>
 
int main()
{
    int age = 28;
    std::cout<<"Age = " << age;
}
```

Инициализация в фигурных скобках
При инициализации после названия переменной в фигурных скобках указывается ее значение:
```
int age {38};
```
В данном случае переменная будет иметь значение 38.

Инициализация в круглых скобках
После названия переменной в круглых скобках указывается ее значение:
```
int age (38); 
```
В данном случае переменная будет иметь значение 38.

Во всех трех случаях присваиваемое переменной значение может представлять сложное вычисляемое выражение.  
Например:
```
int age1 {22 + 5};
int age2 (22 + 5);
int age3 = 22 + 5;
```
Можно сразу инициализировать несколько переменных:
```
int age1 {22}, age2 (23), age3 = 24;
```

Инициализация нулем  
При инициализации в фигурных скобках можно опустить значение:
```
int counter {};
```
В этом случае переменная будет инициализироваться нулем и фактически будет аналогично коду
```
int counter {0};
```
Инициализация по умолчанию
Если переменную не инициализировать, то происходит ее инициализация по умолчанию.  
И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.  
Если переменная, которая представляет встроенный тип (например, тип int), определена внутри функции, то она получает неопределенное значение.  
Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число 0.  

Изменение значения  
```
#include <iostream>
 
int main()
{
    int age = 22;
    std::cout << "Age1 = " << age << "\n";
    age = 23;
    std::cout << "Age2 = " << age << "\n";
    age = 38;
    std::cout << "Age3 = " << age << "\n";
}
```

## Целочисленные типы
- **short** представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).  
Данный тип также имеет псевдонимы short int, signed short int, signed short.  
-  **unsigned short** представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).  
Данный тип также имеет синоним unsigned short int.  
- **int** представляет целое число. Занимает в памяти 4 байта (32 бита).  
Диапазон предельных значений соответственно от −2 147 483 648 до 2 147 483 647 (при 4 байтах).  
Данный тип имеет псевдонимы signed int и signed.  
- **unsigned int** представляет положительное целое число. Занимает в памяти 4 байта (32 бита).  
Диапазон предельных значений от 0 до 4 294 967 295. Имеет псевдоним unsigned.  
- **long** занимает 4 байта и представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647.  
Имеет псевдонимы long int, signed long int и signed long   
- **unsigned long** представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).  
Имеет синоним unsigned long int.  
- **long long** представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти 8 байт (64 бита).  
Имеет псевдонимы long long int, signed long long int и signed long long.  
- **unsigned long long** представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти 8 байт (64 бита).

Для представления чисел в С++ применятся целочисленные литералы со знаком или без, типа -10 или 10.  
Например, определим ряд переменных целочисленных типов и выведем их значения на консоль:
```
#include <iostream>
 
int main()
{
    signed char num1{ -64 };
    unsigned char num2{ 64 };
    short num3{ -88 };
    unsigned short num4{ 88 };
    int num5{ -1024 };
    unsigned int num6{ 1024 };
    long num7{ -2048 };
    unsigned long num8{ 2048 };
    long long num9{ -4096 };
    unsigned long long num10{ 4096 };
    std::cout << "num1 = " << num1 << std::endl;
    std::cout << "num2 = " << num2 << std::endl;
    std::cout << "num3 = " << num3 << std::endl;
    std::cout << "num4 = " << num4 << std::endl;
    std::cout << "num5 = " << num5 << std::endl;
    std::cout << "num6 = " << num6 << std::endl;
    std::cout << "num7 = " << num7 << std::endl;
    std::cout << "num8 = " << num8 << std::endl;
    std::cout << "num9 = " << num9 << std::endl;
    std::cout << "num10 = " << num10 << std::endl;
}
```
Стоит отметить, что все целочисленные литералы по умолчанию представляют тип int.  
Мы можем использовать целочисленные литералы и других типов. Целочисленные литералы без знака (которые представляют unsigned-типы) имеют суффикс u или U.  
Литералы типов long и long long имеют суффиксы L/l и LL/ll соответственно:
```
#include <iostream>
 
int main()
{
    unsigned int num6{ 1024U };         // U - unsigned int
    long num7{ -2048L };                // L - long
    unsigned long num8{ 2048UL };       // UL - unsigned long
    long long num9{ -4096LL };          // LL - long long
    unsigned long long num10{ 4096ULL };// ULL - unsigned long long
    std::cout << "num6 = " << num6 << std::endl;
    std::cout << "num7 = " << num7 << std::endl;
    std::cout << "num8 = " << num8 << std::endl;
    std::cout << "num9 = " << num9 << std::endl;
    std::cout << "num10 = " << num10 << std::endl;
}
```
По умолчанию все стандартные целочисленные литералы представляют числа в привычной нам десятичной системе.  
Однако C++ также позволяет использовать и числа в других системах исчисления.  
Чтобы указать, что число - шестнадцатеричное, перед числом указывается префикс 0x или 0X.  
Чтобы указать, что число - восьмеричное, перед числом указывается ноль 0.  
Бинарные литералы предваряются префиксом 0b или 0B.  
Например:
```
int num1{ 0x1A};        // 26 - в десятичной
int num2{ 0xFF };       // 255 - в десятичной
int num3{ 0xFFFFFF };   //16777215 - в десятичной
int num4{ 034};        // 26 - в десятичной
int num5{ 0377 };       // 255 - в десятичной
int num6{ 0b11010};         // 26 - в десятичной
int num7{ 0b11111111 };     // 255 - в десятичной
```

## Числа с плавающей точкой
Для хранения дробных чисел в C++ применяются числа с плавающей точкой. Число с плавающей точкой состоит из двух частей: мантиссы и показателя степени.  
Оба могут быть как положительными, так и отрицательными. Величина числа – это мантисса, умноженная на десять в степени экспоненты.  
Например, число 365 может быть записано в виде числа с плавающей точкой следующим образом:  
```
3.650000E02
```
В качестве разделителя целой и дробной частей используется символ точки. Мантисса здесь имеет семь десятичных цифр - 3.650000, показатель степени - две цифры 02.  
Буква E означает экспоненту, после нее указывается показатель степени (степени десяти), на которую умножается часть 3.650000 (мантисса), чтобы получить требуемое значение.  
То есть, чтобы вернуться к обычному десятичному представлению, нужно выполнить следующую операцию:  
```
3.650000 × 10^2 = 365
```
Однако хотя такая запись позволяет определить очень большой диапазон чисел, не все эти числа могут быть представлены с полной точность,  
числа с плавающей запятой в целом являются приблизительными представления точного числа.  
Например, число 1254311179 выглядело бы так: 1.254311E09. Однако если перейти к десятичной записи, то это будет 1254311000. А это не то же самое, что и 1254311179, поскольку мы потеряли три младших разряда.  
В языке C++ есть три типа для представления чисел с плавающей точкой:  
-  **float** представляет вещественное число одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)
- **double** представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)
- **long double** представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

В своем внутреннем бинарном представлении каждое число с плавающей запятой состоит из одного бита знака, за которым следует фиксированное количество битов для показателя степени и набор битов для хранения мантиссы.  
В числах float 1 бит предназначен для хранения знака, 8 бит для экспоненты и 23 для мантиссы, что в сумме дает 32 бита. Мантисса позволяет определить точность числа в виде 7 десятичных знаков.  
В числах double: 1 знаковый бит, 11 бит для экспоненты и 52 бит для мантиссы, то есть в сумме 64 бита. 52-разрядная мантисса позволяет определить точность до 16 десятичных знаков.  
Для типа long double расклад зависит от конкретного компилятора и реализации этого типа данных.  
Большинство компиляторов предоставляют точность до 18 - 19 десятичных знаков (64-битная мантисса), в других же long double аналогичен типу double.  
В C++ литералы чисел с плавающими точками представлены дробными числами, которые в качестве разделителя целой и дробной частей применяют точку: 
```
double num {10.45};
double num1{ 1 };    // 1 - целочисленный литерал
double num2{ 1. };  //1. - литерал числа с плавающей точкой
float num1{ 10.56f };    // float
long double num2{ 10.56l };    // long double
double num1{ 5E3  };        // 5E3  = 5000.0
double num2{ 2.5e-3  };    // 2.5e-3  = 0.0025
```
## Символьные типы

В C++ есть следующие символьные типы данных:  

- **char** представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255
- **wchar_t** представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
- **char8_t** представляет один символ в кодировке Unicode. Занимает в памяти 1 байт. Может хранить любой значение из диапазона от 0 до 256
- **char16_t** представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535
- **char32_t** представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295
Мы с вами обратим внимание только на базовый char  
Переменная типа char хранит числовой код одного символа и занимает один байт.
Стандарт языка С++ не определяет кодировку символов, которая будет использоваться для символов char, поэтому производители компиляторов могут выбирать любую кодировку, но обычно это ASCII.  
В качестве значения переменная типа char может принимать один символ в одинарных кавычках, либо числовой код символа:
```
#include <iostream>
 
int main()
{
    char a1 {'A'};
    char a2 {65};
    std::cout << "a1: " << a1 << std::endl;
    std::cout << "a2: " << a2 << std::endl; 
}
```
В данном случае переменные a1 и a2 будут иметь одно и то же значение, так как 65 - это числовой код символа "A" в таблице ASCII.  
При выводе на консоль с помощью cout по умолчанию отображается символ.  
Кроме того, в C++ можно использовать специальные управляющие последовательности, которые предваряются слешем и которые интерпретируются особым образом.   
Например, "\n" представляет перевод строки, а "\t" - табуляцию.  
### Отступление 
Однако ASCII обычно подходит для наборов символов языков, которые используют латиницу.  
Но если необходимо работать с символами для нескольких языков одновременно или с символами языков, отличных от английского, 256-символьных кодов может быть недостаточно.  
И в этом случае применяется Unicode.  
Unicode (Юникод) — это стандарт, который определяет набор символов и их кодовых точек, а также несколько различных кодировок для этих кодовых точек.  
Наиболее часто используемые кодировки: UTF-8, UTF-16 и UTF-32.  
Разница между ними заключается в том, как представлена кодовая точка символа; числовое же значение кода для любого символа остается одним и тем же в любой из кодировок.  
Основные отличия:  
UTF-8 представляет символ как последовательность переменной длины от одного до четырех байт.  
Набор символов ASCII появляется в UTF-8 как однобайтовые коды, которые имеют те же значения кодов, что и в ASCII. UTF-8 на сегодняшний день является самой популярной кодировкой Unicode.  
UTF-16 представляет символы как одно или два 16-битных значения.  
UTF-32 представляет все символы как 32-битные значения  

## Логический тип

Логический тип bool может хранить одно из двух значений: true (истинно, верно) и false (неверно, ложно).  
Например, определим пару переменных данного типа и выведем их значения на консоль:  
```
#include <iostream>
 
int main()
{
    bool isAlive {true};
    bool isDead {false};
    std::cout << "isAlive: " << isAlive << "\n"; 
    std::cout << "isDead: " << isDead << "\n"; 
}
```
При выводе значения типа bool преобразуются в 1 (если true) и 0 (если false).  
Как правило, данный тип применяется преимущество в условных выражениях.  

## Константы

Мы можем многократно в течение работы программы изменять значение переменных:
```
int n {7};
n = 9;
n = 5;
```
Но кроме переменных в языке программирования C++ можно определять константы.  
Их значение устанавливается один раз и впоследствии мы его не можем изменить.  
Константа определяется практически так же, как и переменная за тем исключением, что в начале определения константы идет ключевое слово const.  
Например:
```
const int n {22};
// или 
// const int n = 22;
```
Также в процессе программы мы сможем обращаться к значению константы.  
Но если же мы захотим после определения константы присвоить ей некоторое значение, то компилятор не сможет скомпилировать программу и выведет ошибку.  
Если константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать программу.  
В качестве значения константам можно передавать как обычные литералы, так и динамически вычисляемые значения, например, значения переменных или других констант:
```
int a {10};
const int b {7};
const int d {b};
const int x {a};
```
Обычно в качестве констант определяются такие значения, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены.  
Например, если программы выполняет математические операции с использованием числа PI, то было бы оптимально определить данное значение как константу, так как оно все равно в принципе неизменно.

## Типизация и преобразования типов

С++ является статически типизированным языком программирования.  
То есть если мы определили для переменной какой-то тип данных, то в последующем мы этот тип изменить не сможем.  
Соответственно переменная может получить значения только того типа, который она представляет. Однако нередко возникает необходимость присвоить переменной значения каких-то других типов.  
И в этом случае применяются преобразования типов.
Ряд преобразований компилятор может производить неявно, то есть автоматически. Например:
```
#include <iostream>
 
int main()
{
    unsigned int age{25};
    std::cout << "age = " << age << std::endl;
}
```
Переменная age представляет тип unsigned int и условно хранит возраст. 
Эта переменная инициализируется числом 25, а все целочисленные литералы без суффиксов по умолчанию представляют тип int (signed int).  
Но компилятор знает как преобразовать значение 25 к типу unsigned int, и каких-то проблем в данном случае не будет.

**Примеры неявных преобразований**
```
// Переменной типа bool присваивается значение другого типа. В этом случае переменная получает false, если значение равно 0.
// Во всех остальных случаях переменная получает true.
bool a = 1;     // true
bool b = 0;     // false
bool c = 'g'; // true
bool d = 3.4;   // true

// Числовой или символьной переменной присваивается значение типа bool.
// В этом случае переменная получает 1, если значение равно true, либо получает 0, если присваиваемое значение равно false.
int c = true;       // 1
double d = false;   // 0

// Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается.
int a = 3.4;        // 3
int b = 3.6;        // 3

// Переменной, которая представляет тип с плавающей точкой, присваивается целое число.
// В этом случае, если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается.
float a = 35005;                // 35005
double b = 3500500000033;       // 3.5005e+012

// Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона.
// В этом случае результатом будет остаток от деления по модулю. Например, тип unsigned char может хранить значения от 0 до 255.
// Если присвоить ему значение вне этого диапазона, то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений).
// Так, при присвоении значения -5 переменная типа unsigned char получит значение 251
unsigned char a = -5;           // 251
unsigned short b = -3500;       // 62036
unsigned int c = -50000000;     // 4244967296

// Переменной знакового типа (signed) присваивается значение не из его диапазона. В этом случае результат не детерминирован.
// Программа может выдавать адекватный результат, а может работать некорректно.
```
**Опасные и безопасные преобразования**

Те преобразования, при которых не происходит потеря информации, являются безопасными.  
Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью.  
В частности, это следующие цепочки преобразований:

**bool -> char -> short -> int -> double -> long double**  
**bool -> char -> short -> int -> long -> long long**  
**unsigned char -> unsigned short -> unsigned int -> unsigned long**  
**float -> double -> long double**  
Примеры безопасных преобразований:  
```
short a = 'g'; // преобразование из char в short
int b = 10;
double c = b; // преобразование из int в double
float d = 3.4;
double e = d; // преобразование из float в double
double f = 35; // преобразование из int в double
```  
Примеры опасных преобразований:  
```
unsigned int a = -25;           // 4294967271
unsigned short b = -3500;       // 62036 
```  
Если речь идет об инициализации переменных, то, чтобы избежать опасных преобразований, когда может произойти потеря точности, рекомендуется использовать инициализацию в фигурных скобках:
```
unsigned int a {-25};           // ! Ошибка 
unsigned short b {-3500};       // ! Ошибка 
```

**Явные преобразования типов**

Дальше мы разберем разные механизмы явных преобразований, но во  времена динозавров в С++ применялась операция преобразования, унаследованная от языка Си.
Будем пока использовать именно ее 
```
(тип) значение
```
То есть перед преобразуемым значением в круглых скобках указывался тип, в который надо выполнить преобразование.
Например:
```
#include <iostream>
 
int main()
{
    double sum {100.2};
    unsigned int hours {8};
    unsigned int revenuePerHour { (unsigned int)sum/hours};     // revenuePerHour = 12
    std::cout << "Revenue per hour = " << revenuePerHour<< std::endl;
}
```
## Арифметические операции

Арифметические операции производятся над числами. Значения, которые участвуют в операции, называются операндами.  
В языке программирования C++ арифметические операции могут быть бинарными (производятся над двумя операндами) и унарными (выполняются над одним операндом).  

    
К бинарным операциям относят следующие:
- **+ Операция сложения возвращает сумму двух чисел**
```
int a {10};
int b {7};
int c {a + b};  // 17
int d {4 + b};  // 11
// или
int c = a + b;  // 17
int d = 4 + b;  // 11
```
- **-  Операция вычитания возвращает разность двух чисел**
```
int a {10};
int b {7};
int c {a - b};  // 3
int d {4 - b};  // -3
```
- **\* Операция умножения возвращает произведение двух чисел**
```
int a {10};
int b {7};
int c {a * b};  // 70
int d {4 * b};  // 28
```
- **/ Операция деления возвращает частное двух чисел**
```
int a {26};
int b {5};
int c {a / b};      // c = 5
int d {4 / b};     // d = 0
```
При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то дробная часть (при ее наличии) будет отбрасываться, даже если результат присваивается переменной float или double:
```
#include <iostream>
 
int main()
{
    int a {26};
    int b {5};
    float c {a / b};      // c = 5
    double d {4 / b};     // d = 0
    std::cout << "c = " << c << std::endl;
    std::cout << "d = " << d << std::endl;
}
```
Чтобы результат представлял число с плавающей точкой, один из операндов также должен представлять число с плавающей точкой:
```
#include <iostream>
 
int main()
{
    float a {26};
    int b {5};
    float c {a / b};        // c = 5.2
    double d {4.0 / b};     // d = 0.8
    std::cout << "c = " << c << std::endl;
    std::cout << "d = " << d << std::endl;
}
```
- **% Операция получения остатка от целочисленного деления**
```
int a {26};
int b {5};
int c {a % b};      // c = 26 % 5 = 26 - 5 * 5 = 1
int d {4 % b};     // d = 4 % 5 = 4
```

## Инкремент и декремент

Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:  

- Префиксный инкремент.  
Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++x
```
#include <iostream>
 
int main()
{
    int a {8};
    int b {++a};
    std::cout << "a = " << a << std::endl;  // a = 9
    std::cout << "b = " << b << std::endl;  // b = 9
}
```
- Постфиксный инкремент.
Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу
```
#include <iostream>
 
int main()
{
    int a {8};
    int b {a++};
    std::cout << "a = " << a << std::endl;  // a = 9
    std::cout << "b = " << b << std::endl;  // b = 8
}
```
- Префиксный декремент
Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x
```
#include <iostream>
 
int main()
{
    int a {8};
    int b {--a};
    std::cout << "a = " << a << std::endl;  // a = 7
    std::cout << "b = " << b << std::endl;  // b = 7
}
```
- Постфиксный декремент.  
Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу
```
#include <iostream>
 
int main()
{
    int a {8};
    int b {a--};
    std::cout << "a = " << a << std::endl;  // a = 7
    std::cout << "b = " << b << std::endl;  // b = 8
}
```

## Приоритет и ассоциативность операторов

Операторы могут быть левоассоциативными - такие операторы выполняются слева направо и правоассоциативными - выполняются справа налево.  
Подавляющее большинство операторов левоассоциативны (например, бинарные арифметические операции), поэтому большинство выражений оценивается слева направо.  
Правоассоциативными операторами являются все унарные операторы, различные операторы присваивания и условный оператор.  
Кроме того, одни операции имеют больший приоритет, чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:  
++ (инкремент), -- (декремент)  
\* (умножение), / (деление), % (остаток от деления)  
\+ (сложение), - (вычитание)
  
Приоритет операций следует учитывать при выполнении набора арифметических выражений:  
```
int a = 8;
int b = 7;
int c = a + 5 * ++b;      // 48
```
Хотя операции выполняются слева направо, но вначале будет выполняться операция инкремента ++b, которая увеличит значение переменной b и возвратит его в качестве результата, так как эта операция имеет больший приоритет.  
Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b  
Следует учитывать, что если в одной инструкции для одной переменной сразу несколько раз вызываются операции инкремента и декремента, то результат может быть неопределенным, и много зависит от конкретного компилятора.  
Например:
```
int count {1};
int result = ++count * 3 + count++ * 5;
```
Так, и g++, и clang++ скомпилируют данный код, и результат переменной result будет таким, как в принципе и ожидается - 16, но компилятор clang++ также сгенерирует предупреждение.  

**Переопределение порядка операций**
Скобки позволяют переопределить порядок вычислений. Например:
```
#include <iostream>
 
int main()
{
    int a {8};
    int b {7};
    int c {(a + 5) * ++b};      // c = 104
    std::cout << "c = " << c << std::endl;
}
```
Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.  

**Преобразования в арифметических операциях**  

В арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип.  
Если же операнды имеют разные типы, то компилятор автоматически выбирает операнд с типом который имеет меньший диапазон  
значений и пытается его преобразовать в тип второго операнда, который имеет больший диапазон значений.  
С точки зрения преобразований в операциях типы можно расположить следующим образом в порядке приоритета (от более высокого к более низкому):  

- long double
- double
- float
- unsigned long long
- long long
- unsigned long
- long
- unsigned int
- int
То есть, если в операции участвует число типа float и типа long double, то компилятор автоматически преобразует операнд типа float в тип long double
(который в соответствии с вышеуказанным списком имеет более высокий приоритет). Операнды типов char, signed char, unsigned char, short и unsigned short
всегда при операциях преобразуются как минимум в тип int


